name: Build and Deploy Pipeline

on:
  push:
    branches:
      - main # O la rama principal que uses, ej: master
  pull_request:
    types: [opened, synchronize, reopened]

env:
  # Define la etiqueta base de la imagen para usar en todos los jobs
  IMAGE_NAME: "${{ secrets.DOCKER_USERNAME }}/my-django-app"
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # === JOB 1: Construir Imagen y Ejecutar Pruebas ===
  build_and_test:
    name: Build & Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Build the Docker image
        id: docker_build
        # Etiquetamos la imagen localmente con el SHA del commit
        run: docker build -t ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} .

      - name: Run Django Tests
        # Ejecutamos las pruebas dentro del contenedor para simular el entorno de producción
        # Reemplaza 'python manage.py test' si usas otro comando (ej: pytest)
        run: |
          echo "Running tests inside Docker container..."
          docker run --rm ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} sh -c "python manage.py test"
        
      # Si las pruebas fallan, el flujo se detiene aquí.
      
  # === JOB 2: Subir la Imagen a Docker Hub ===
  push_docker_image:
    name: Push to Docker Hub
    runs-on: ubuntu-latest
    needs: [build_and_test] # Solo se ejecuta si la construcción y las pruebas pasan

    steps:
      # Aunque este job no usa el código, checkout es buena práctica
      - name: Checkout Code (for context/artifacts, if needed)
        uses: actions/checkout@v3
        
      # Construimos la imagen de nuevo. En un pipeline real, usarías un Artifact
      # o un Registry intermedio, pero en un runner simple, lo más fácil es reconstruir/cachear.
      # Usamos el mismo build para garantizar que el SHA es el correcto.
      - name: Re-Build Image (for consistency)
        run: docker build -t ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} .

      - name: Log in to Docker Hub
        # Usamos una acción estándar para autenticarse en Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Push to Docker Hub
        # Empujamos la imagen etiquetada con el SHA
        run: |
          docker push ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          
          # Opcional: También la etiquetamos y la subimos como 'latest'
          docker tag ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} ${{ env.IMAGE_NAME }}:latest
          docker push ${{ env.IMAGE_NAME }}:latest

  # === JOB 3: Análisis de Código con SonarCloud ===
  sonarcloud:
    name: SonarCloud
    runs-on: ubuntu-latest
    # SonarCloud puede ejecutarse en paralelo o después de las pruebas, 
    # pero asegurémonos de que el código base esté limpio
    needs: [build_and_test] 
    
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Necesario para el escaneo de SonarCloud
          
      # Aquí podrías añadir la instalación de Python y dependencias
      # si SonarCloud necesita acceder al código fuente y no solo a la imagen.

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}